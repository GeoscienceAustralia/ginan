<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ginan: /data/acs/ginan/src/Architecture/Pea.Configuration.Examples File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="general.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="GinanLogo60.png"/></td>
  <td id="projectalign">
   <div id="projectname">Ginan
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle"><div class="title">/data/acs/ginan/src/Architecture/Pea.Configuration.Examples File Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Examples of basic pea use-cases and configuration file templates for their use.</p>
<h1><a class="anchor" id="autotoc_md565"></a>
The files</h1>
<p >Ginan is controlled by Yet Another Markup Language (YAML) configuration files. The Ginan YAML files are formatted in hierarchical sections that are delimited by indentation. More information on the YAML format refer to the standard reference. Yaml files control all aspect s of a Ginan processing including; the data that Ginan looks for, how that data is processed and the type of outputs that are produced. Ginan yaml files can get very big and complex - there are over a thousand possible parameter settings within Ginan. Because of this, for version 2, yaml files can be broken up into parts – which are themselves yaml files. This means that you can dedicate individual files to certain tasks, such as having a file that controls the inputs, another that controls outputs and third that determines processing. Hopefully this allows for better and more concise control of Ginan. <a class="el" href="structA.html">A</a> user can use the same input and output yaml’s, while studying the effects of different processing options. For example, in this file <code>ex204.yaml</code>, four other yaml files are specified:</p>
<div class="fragment"><div class="line"> </div>
<div class="line">inputs:</div>
<div class="line">    include_yamls:</div>
<div class="line">        - input_metadata.yaml</div>
<div class="line">        - input_files_network.yaml</div>
<div class="line">        - processing_network.yaml</div>
<div class="line">        - processing_network_biases.yaml</div>
<div class="line">        - mongo_outputs.yaml</div>
<div class="line">        - debug_trace.yaml</div>
<div class="line">    </div>
<div class="line">    erp_files:  [ IGS1R03SNX_20191950000_07D_01D_ERP.ERP        ]       </div>
<div class="line">    satellite_data:</div>
<div class="line">        nav_files: [ brdm1990.19p                               ]</div>
<div class="line">        sp3_files: [ IGS2R03FIN_20191990000_01D_05M_ORB.SP3     ]</div>
<div class="line">    </div>
<div class="line">outputs:</div>
<div class="line">    metadata:</div>
<div class="line">        config_description:     &quot;ex204&quot;</div>
<div class="line"> </div>
<div class="line">processing_options:</div>
<div class="line">    gnss_models:</div>
<div class="line">        ionospheric_component2:</div>
<div class="line">            enable:             true</div>
<div class="line">        ionospheric_component3:</div>
<div class="line">            enable:             true</div>
<div class="line">    gnss_general:</div>
<div class="line">        common_sat_pco:         true</div>
<div class="line">        common_rec_pco:         true</div>
<div class="line">    filter_options:</div>
<div class="line">        rts:</div>
<div class="line">            enable:         true</div>
<div class="line">            directory:      ./    # WARNING: RTS Smoothing for network solutions may generate files of up to 1TB in size, </div>
<div class="line">                                  # make sure there is enoough disk space for these files </div>
</div><!-- fragment --><p >The order that yaml files are specified is not critical. Ginan will look for information in the order it needs it, rather than the order in a file like ex204. The Ginan GitHub repository contains examples of yaml files. <a class="el" href="structA.html">A</a> user is free to create their own versions – the obvious guiding principles are: • Files should contain parameter settings that deliver the outcomes the user requires, • Different yaml files shouldn’t contain parameter settings that contradict each other, • Be wary of behaviour that arises from the fact a parameter wasn’t explicitly set and a default value was applied. Another feature is that Ginan can operate using a hierarchy of information sources. For example, clock information could come from the Kalman filter. If that is missing, then Ginan can use a precise clock file. Failing that, the system can pick up the broadcast clock information. Data and Metadata Inputs</p>
<div class="fragment"></div><!-- fragment --><p >Metadata input configurations This inputs yaml file describes all of the auxillary data and metadata inputs for this run of Ginan. The root directory is where Ginan will look for all the metadata products to be used. snx_files: contain a priori information about the stations that are to be used in the Ginan processing. From the SINEX files Ginan extracts information about the station location, receiver, and antenna type as well as satellites specific meta data necessary to process the observations. Various sinex file types can be read by Ginan including station sinex files and satellite meta data sinex files. atx_files: specify the relevant antex files. These files contain details on satellite and receiver antennas including data on phase center variation (PCV) and phase center offset (PCO). blq_files: contain station specific ocean loading corrections. erp_files: are the earth orientation parameters to be used in the processing. The next three file types are new to version 2. Strictly speaking they are not needed unless you are estimating satellite orbital States, but we recommend that they are included: egm_files: is the spherical harmonic coefficients representing the Earths gravity field. jpl_files: the planetary ephemeris file is used to get the Sun and Moon position for determining the nominal attitude for the GNSS satellites and for computing the gravitational effect of the Sun, Moon and solar system planets on satellites tide_files: the spherical harmonic coefficients representing global ocean tidal model, used for computing the gravitational effect of the ocean tides on satellites Note that the egm and tide files are only relevant for the orbit propagator or integrator. The satellite_data: files are relevant here because this is part of a post-processed example. These would not be needed for real-time processing unless there was a requirement to use a predefined set of biases for the analysis. satellite_data: includes general satellite ephemeris and clock offset in the form of a navigation file, IGS RINEX clock format file and a bias file in the new IGS BIA sinex format. In this case SP3 files provide precise orbit positions. The troposphere: section contains information about the troposphere model to be used in the data processing. Information about the location of the GPT2 troposphere model files and the VMF3 grid files are given. <a class="el" href="structObservation.html">Observation</a> Inputs The yaml below large_post_network.yaml demonstrates how to specify a range of observation inputs (RINEX files) from a number of stations, to be processed by Ginan. The inputs_root: data/ identifies the location of the files. The rnx_inputs: tells Ginan the files are in RINEX format. This kind of yaml observation input might be used for post-processing a large network of stations..</p>
<div class="fragment"></div><!-- fragment --><p >Alternatively, Ginan can be configured to take and process observations from real-time streams. This kind of configuration is shown in tiny_realtime_network.yaml below. The directory name has been replaced by the stream mount point in inputs_root: and the type of stream has been identified using rtcm_inputs:.</p>
<div class="fragment"></div><!-- fragment --><p >Outputs This next file contains a range of configuration settings that determine what the user wants Ginan to output from the processing. In this case the file is called network_clocks_and_biases.yaml, but the user can give their file any name which is appropriate and meaningful to them. The root_directory: is the directory where the user wants all the outputs to be put. In this case it is outputs/&lt;CONFIG&gt;/ where &lt;CONFIG&gt; is an alias whose value is derived from the config_description: setting. Outputs: metadata: config_description: "ex204" It could just be an absolute pathname as well. Ginan can produce trace files which summarise information read or computed as the processing proresses. Trace files contain a lot of information on the internal workings of Ginan. <a class="el" href="structA.html">A</a> user can control the level of information in a trace file using the level parameter. The higher the number (up to 6) the more verbose the information written to the Trace files. There are two types of trace file: output_stations: informs the user as to what is happening in the processing for each station, output_network: informs the user what the Kalman filter is doing to combine that data into a solution. Then the user can turn flags to true to have certain types of data included in the trace files like output_residuals: and the output_residual_chain: will tell the user about the components used in the processing.The output_config: true line tells Ginan to write the contents of input yaml configuration setting file/s into the top of output trace files so the user has a record of the settings used. ppp_sol, when true, gives the precise point positions in a file of their own. outputs: root_directory: outputs/&lt;CONFIG&gt;/ trace: output_stations: true output_network: true level: 3 station_filename: &lt;STATION&gt;_&lt;YYYY&gt;&lt;DDD&gt;&lt;HH&gt;.TRACE network_filename: &lt;STATION&gt;_&lt;YYYY&gt;&lt;DDD&gt;&lt;HH&gt;.TRACE output_residuals: true output_residual_chain: true output_config: true ppp_sol: output: true If the user was running an ionosphere estimation solution and wanted to save the Global Ionosphere <a class="el" href="structModel.html">Model</a> (GIM) spherical harmonic States, setting the ionex output: true, and specifying a directory and filename would save the output to that location. Similarly a user can choose to output the slant total electron content estimates if they're doing uncombined undifferenced processing – ionstec:. bias_sinex: allows a user to turn on saving estimated bias States to a standard bias sinex format file.. In the example below the satellite biases are true but the receiver biases are false (would not be produced) and the output interval is set to 900 seconds. Seconds are the default units.clocks: true, produce the clock file and include the ambiguity resolved clocks into the file.sinexsinex:output: true, turns on the standard position sinex file output. This file also contains the summary of the metadata that was used to produce the solution - all of the antenna offsets, receiver and antenna types are documented in the output syntax file. That makes it a good reference source. ionex: output: false directory: ./ filename: AUSG&lt;DDD&gt;0.&lt;YY&gt;I ionstec: output: false directory: ./ filename: IONEX.stec bias_sinex: output: true output_rec_bias: false code_output_interval: 900 phase_output_interval: 900 clocks: output: true output_ar_clocks: true sinex: output: true erp: Earth Rotation Parameters written out into a standard ISO <a class="el" href="structERP.html">ERP</a> file format. trop_sinex: troposphere estimates into a troposphere sinex file format. Generally, it’s best to have the source of the troposphere estimates as [KALMAN] from the Kalman filter. erp: output: true trop_sinex: output: true sources: [KALMAN] Processing options Options start with the data interval – the example shows using 60 second data – epoch_interval. wait_next_epoch: how long Ginan will wait for the next epoch of data to arrive. For post processing, the user can set that to be a very long time because there is usually no problem waiting any amount of time for all the rinex files to be read together as a single epoch. The example below will wait an hour for the next epoch interval to come in. If the user is processing in real time, that should be set to less than the sampling interval to be used. If one Hertz data is to be used, then Ginan would wait for the next one or two seconds for all of the data to come in and then process it – so 3 seconds in total. wait_all_stations: If a user is doing network processing where they're generating clocks and biases for instance, Ginan will wait for thoese three seconds for the next epoch of data, then wait an additional one second for the whole network that is defined to come in, and then process what is there. fatal_level_message: when set to 1 will stop Ginan processing on any error message. It can be set up to 3, which tells Ginan to keep processing no matter what the errors being generated. process_modes: in version 1 of Ginan there was the concept of User and <a class="el" href="structNetwork.html">Network</a> mode. All the version 2 code however is accessed using this ppp: true mode. Within this mode there are options to use the ionosphere-free or undifferenced-uncombined set by parameters discussed later. processing_options: epoch_control: epoch_interval: 60 wait_next_epoch: 3600 # Wait up to an hour for next data point - When processing RINEX causes PEA to wait a long as need for last epoch to be processed. wait_all_stations: 1 fatal_message_level: 1 process_modes: ppp: true In gnss_general: elevation_mask: hides observations from satellites below the specified number of degrees above the horizon. rec_reference_system: in this example is set to GPS. Then there are options about the information used from sinex files, require_antenna_details: in this example is set to true. It can be set false in which case Ginan will produce a solution without reference to antenna details such as PCV and PCO. <a class="el" href="structA.html">A</a> position can be produced but the height might be a bit off. require_apriori_positions: is usually set to false because a user can get good position information from the single point position estimate using the code data. <a class="el" href="structA.html">A</a> good a priori position is not required unless the user is using that station as a reference station in their solution. Ginan will provide alerts to say when processing has continued without antenna or a priori information. gnss_general: elevation_mask: 10 # degrees rec_reference_system: GPS require_antenna_details: true # (bool) require_apriori_positions: false # (bool) sys_options: this section is giving the user options around the use of constellations. This example instructs Ginan to only use GPS – the other constellations are commented out and you could include Beidou. If a constellation is included, it makes sense that the user provides observation data from that constellation. If no observation data is provided for a constellation nothing will get processed. In this example: process GPS, do not do ambiguity resolution in this case, and do not reject satellites that are in eclipse. There are options to set the way differential code biases (DCB) are handled for receiver and satellite. There are clock and code frequencies specified - setting zero_receiver_dcb: true would set the DCB between L1W and L2 to be zero, unless that receiver does not track L1W, in which case it's going to select L1C and L2W. network_amb_pivot: in order to eliminate the ranked efficiency that comes from the phase bias and ambiguities, this fixes one ambiguity per satellite and one ambiguity per station, which eliminates sensitivity - trade off the ambiguities against the phase biases, essentially. clock_codes: the user can define how they want their output clocks to be defined. In this case, the standard L1WL2 IGS convention for clocks has been specified, even though it's probably not the most obvious one to choose these days. But that's what the IGS uses so this goes with that convention. These are the codes to be used in this particular processing example - dual frequency using L1W. sys_options: gps: process: true ambiguity_resolution: false # Do not turn on AR if using ppp: - use_if_combo: true reject_eclipse: false zero_receiver_dcb: true #zero_satellite_dcb: true network_amb_pivot: true clock_codes: [ L1W, L2W ] code_priorities: [ L1W, L1C, L2W ] </p>
<h1><a class="anchor" id="autotoc_md566"></a>
gal:</h1>
<h1><a class="anchor" id="autotoc_md567"></a>
process: true</h1>
<h1><a class="anchor" id="autotoc_md568"></a>
ambiguity_resolution: false</h1>
<h1><a class="anchor" id="autotoc_md569"></a>
reject_eclipse: false</h1>
<h1><a class="anchor" id="autotoc_md570"></a>
code_priorities: [ L1C, L5Q, L1X, L5X ]</h1>
<h1><a class="anchor" id="autotoc_md571"></a>
glo:</h1>
<h1><a class="anchor" id="autotoc_md572"></a>
process: true</h1>
<h1><a class="anchor" id="autotoc_md573"></a>
ambiguity_resolution: false</h1>
<h1><a class="anchor" id="autotoc_md574"></a>
reject_eclipse: true</h1>
<h1><a class="anchor" id="autotoc_md575"></a>
code_priorities: [ L1P, L1C, L2P, L2C ]</h1>
<h1><a class="anchor" id="autotoc_md576"></a>
qzs:</h1>
<h1><a class="anchor" id="autotoc_md577"></a>
process: true</h1>
<h1><a class="anchor" id="autotoc_md578"></a>
ambiguity_resolution: false</h1>
<h1><a class="anchor" id="autotoc_md579"></a>
reject_eclipse: true</h1>
<h1><a class="anchor" id="autotoc_md580"></a>
code_priorities: [ L1C, L2L, L2X ]</h1>
<p >gnss_models: this section is about applying models for GNSS processing. There are a large number of options. Following are explanations of some of the more significant options. sat_attitude: The choices here are to use nominal, which is to use the nominal attitude based on the Sun's location all the time. Or the user can turn on Ginans yaw attitude modelling code which is based on the models used in standard IGS analysis software for all the constellations. At the moment Ginan has yaw attitude modelling completed for GPS Galileo. rec_attitude: use [NOMINAL] for the time being. <a class="el" href="structA.html">A</a> sinex format receiver attitude model is under development. troposphere: a VMF3 or GPT2 model can be selected given that the input model files are provided (in a previous section). gnss_models: sat_attitude: sources: [MODEL] rec_attitude: sources: [NOMINAL] troposphere: model: vmf3 # gpt2 ionospheric_component: this is where the user can specify the use of an ionosphere free or uncombined processing model. common_ionosphere: should be kept as true and means the same ionosphere model is used for code and carrier wave. use_if_combo: if set to false uses data in an uncombined way. If true then will use an ionosphere linear combination choosing frequency observations that are present then based on the order specified previously. There is no spatial correlation of the ionosphere – so no correlation between stations – but there is temporal correlation defined by process noise – coming in a later part of this file. model_error_checking: is to determine what to do with bad data. Ginan doesn't ever actually remove observations from processing, it “down weights” them in the processing. This parameter set specifies that when a bad observation is found it will down weight the measurement variance by a factor of 10,000 in this case. So if the Kalman filter through its checking finds a bad observation, it will then apply multiply the variance the measurement variance by 10,000 and that eliminates it from having weight in the solution. ambiguities: when to reset ambiguities and the solution when a problem is found. outage_reset_limit: defines a data gap to be before it resets the ambiguity automatically In this case, the setting is 10. Ginan can have 10 missing observations before the ambiguity will reset automatically. Because this example is using 60 second data, Ginan would allow 600 seconds before the ambiguity was reset in the filter. phase_reject_limit: if Ginan detects a four Sigma outlier twice in a row (that number 2), it will then reset the phase ambiguity and start estimating a new one. reinit_on_all_slips: if true means that if all channels lose lock simultaneously, then Ginan have a data gap and reset all the ambiguities - because it won’t be able to determine which ones might be OK and which ones are not. ionospheric_component: common_ionosphere: true # Code and Phase measurment share the same ionosphere use_if_combo: false model_error_checking: deweighting: deweight_factor: 10000 ambiguities: outage_reset_limit: 10 phase_reject_limit: 2 reinit_on_all_slips: true # (bool) Any detected slips cause removal and reinitialisation of ambiguities If ambiguity resolution was turned on (see above) this is where its options are defined. The methods are the same as those for version 1. The only difference is that rounding is not recommended for an uncombined solution. outlier_screening: the number of iterations the Kalman filter should attempt to remove bad observations before it gives up. In this example 50 iterations. If the user sets that number too large, usually it doesn't hurt because the preprocessor does a pretty good job of getting all the bad data before it comes into the filter. If the preprocessor is not working well for some reason, then the filter will iterate removing bad observations weighting them down with that factor of 10,000 until it's either got them all or until it hits the 50 limit - and then it will just continue processing, even if it determines there is bad data in the in the solution, so its one of the things that's worthwhile checking the trace file - how often that limit is being hit. We haven’t seen it hit 50. If it does, it probably means there's some other problem with the data and not just single outliers. max_prefit_removals: the option before the data enters the filter to do a prefit scan and remove bad data at the prefit step, which is a bit cheaper in terms of computational time. sigma_check: from before, a 4 sigma outlier is flagged as bad and will be down weighted in the filter. rts: Ginan can do a Rauch-Tung-Striebel (RTS) backwards smoothing run. There is no point doing that for real-time processing because you never get to the “end” when the backward smoothing would start – so set to false. For post-processing it makes sense, but as mentioned previously, not when doing ambiguity resolution. minimum_constraints: Ginan can apply a transformation of your estimated position states to the reference frame defined by a priori coordinates and the sinex file. Transformations can be translations, rotations and scales – in this case scale is set false. If the user sets minimum_constraints to true, they have the choice of doing the transformation every epoch, apply the minimum constraint and output the results every step of the common filter. Alternatively, if set to false, Ginan will just apply the minimum constraint when it gets to the end of the data, apply it and then do the backward smoothing. If the user wanted to get minimally constrained real-time products out, they would set this once_per_epoch: true, so that they would get a minimally constrained solution at every step of the of the filter. full_vcv: Ginan provides the option to weight stations in that minimum constraint – the user can specify what the North-East-Up variance on the measurements going into the minimal constraint calculation should be. There are other options to weight that by the variance covariance matrix or some scaled version of the variance covariance matrix. max_filter_iterations: this function has the same outlier filtering and removal option that the main filter has. <a class="el" href="structA.html">A</a> user can tell the filter to iterate the minimum constraint calculation up to 20 times removing bad stations from that minimum constraint calculation as it goes. sigma_threshold: these options are all common – in this example the Sigma threshold for removing bad stations has been set to 3 instead of the default 4. #ambiguity_resolution: </p>
<h1><a class="anchor" id="autotoc_md581"></a>
elevation_mask: 15</h1>
<h1><a class="anchor" id="autotoc_md582"></a>
lambda_set_size: 200</h1>
<h1><a class="anchor" id="autotoc_md583"></a>
narrow_lane:</h1>
<h1><a class="anchor" id="autotoc_md584"></a>
mode: lambda_bie # off, bootst,</h1>
<p >lambda, lambda_alt, lambda_al2, lambda_bie </p>
<h1><a class="anchor" id="autotoc_md585"></a>
success_rate_threshold: 0.99</h1>
<h1><a class="anchor" id="autotoc_md586"></a>
solution_ratio_threshold: 30</h1>
<p >filter_options: outlier_screening: max_filter_iterations: 50 max_prefit_removals: 3 sigma_check: true rts: enable: true minimum_constraints: enable: true once_per_epoch: false # (bool) Perform minimum constraints on a temporary filter and output results once per epoch translation: estimated: [true] rotation: estimated: [true] scale: estimated: [false] #sigma: [1] #full_vcv: true #scale_by_vcv: true max_filter_iterations: 20 max_prefit_removals: 3 # (int) Maximum number of measurements to exclude using prefit checks before attempting to filter outlier_screening: chi_square_mode: none chi_square_test: false sigma_check: true sigma_threshold: 3 w_test: false station_noise: global: [0.01, 0.01, 0.01] station_options: a user can define things in this section that were not in the metadata section. In this example there were some stations missing from the sinex file If there isn’t a sinex file entry for a particular site, a user can just add the site into the station options list along with receiver, antenna and eccentricity information for them. The other thing a user can do is set aliases for sites. In this example USN7 has been given the alias [PIVOT] and the example shows how that is used later. These aliases can be anything a user wants. It's just it's just a way of using those sites for various things without having to relist them each time. station_options: RAEG: receiver_type: "LEICA GR25" antenna_type: "LEIAR20 NONE" eccentricity: [0.0000, 0.0000, 0.5793] DUMG: receiver_type: "LEICA GR25" antenna_type: "LEIAR25.R4 LEIT" eccentricity: [0.0003, -0.0005, 0.4278] GAMB: receiver_type: "TRIMBLE NETR9" antenna_type: "TRM59800.00 NONE" eccentricity: [0.0000, 0.0000, 0.0000] GLPS: receiver_type: "JAVAD TRE_G3TH DELTA" antenna_type: "ASH701945B_M SCIT" eccentricity: [0.0000, 0.0000, 0.0083] KITG: receiver_type: "SEPT POLARX5" antenna_type: "TRM59800.00 SCIS" eccentricity: [0.0000, 0.0003, 2.0374] USN7: aliases: [PIVOT] AGGO: aliases: [ADD_CLOCK_RATES] estimation_parameters: this is very similar to Ginan version one. There are two parts – a stations: and a satellite: section. In the stations: section, a user can define the error model to be used for the observations is. In this example, an elevation dependent model is to be applied to the observations to set the measurement variances or sigmas in this case - variance, the square root of variance code Sigma and phase Sigma. <a class="el" href="structA.html">A</a> user can specify what states to estimate and the starting uncertainty and process noise to be applied to those states is. They can be defined per station or for all stations after the global: line - apply the following things for all stations that are in the solution. For example, all stations have position estimated with this uncertainty of 1 metre and no process noise. If the sites were kinematic you would set that process noise to be a non 0 number. estimation_parameters: stations: error_model: elevation_dependent code_sigmas: [0.3] phase_sigmas: [0.002] global: pos: estimated: [true] sigma: [1] proc_noise: [0] clk: estimated true, sigma is 1000 metres and process noise of 10 metres per square root second. amb: sigma is 100 cycles, not metres. trop: troposphere is estimated with a priori sigma and a process noise. The troposphere is probably one place where a First order Gauss-Markoff process noise would be useful where there is a slow highly correlated part of the atmosphere with a more variable part which could be parameterized. The zenith tropospheric delay has gradients in the north, south and east west directions parameterised through the gradients. ion_stec: in TCU – in this example there is an initial uncertainty of 100 TCU and then this is to be allowed to change 2 TCU per square root second - the constraint. clk: estimated: [true] sigma: [1000] proc_noise: [10] amb: estimated: [true] sigma: [100] proc_noise: [0] trop: estimated: [true] sigma: [0.3] proc_noise: [0.0001] trop_grads: estimated: [true] sigma: [0.03] proc_noise: [1.0E-6] ion_stec: estimated: [true] sigma: [100] proc_noise: [2] phase_bias: estimated: [true] sigma: [10] proc_noise: [0] code_bias: estimated: [true] sigma: [20] proc_noise: [0] #GPS: </p>
<h1><a class="anchor" id="autotoc_md587"></a>
L2W:</h1>
<h1><a class="anchor" id="autotoc_md588"></a>
amb:</h1>
<h1><a class="anchor" id="autotoc_md589"></a>
estimated: [false]</h1>
<h1><a class="anchor" id="autotoc_md590"></a>
sigma: [1e-8]</h1>
<h1><a class="anchor" id="autotoc_md591"></a>
proc_noise: [0]</h1>
<p >Earlier on in the example the station USN7 was given the name PIVOT. USN7 has a good atomic clock and in this example is set to be the clock reference through the label PIVOT. In this case nothing is to be estimated including code and phase biases. PIVOT: clk: estimated: [false] # Set reference (pivot) station clock code_bias: estimated: [false] phase_bias: estimated: [false] ADD_CLOCK_RATES: clk_rate: estimated: [true] sigma: [10] proc_noise: [1e-8] satellite: has a global option to affect everything for all the satellites - estimating the clocks, clock rate, phase and code biases for all the satellites as well. This example is aimed at generating a solution and removing the rank deficiency, so set the code biases on the GPS system L1 and L2W to be 0, with a very small sigma. They will still appear in the output but because they have a very small sigma of 10 to the minus 8 they are constrained them onto that value in this solution for the GPS system. satellites: global: clk: estimated: [true] sigma: [1000] proc_noise: [1] clk_rate: estimated: [true] sigma: [10] proc_noise: [1e-9] phase_bias: estimated: [true] sigma: [10] proc_noise: [0] code_bias: estimated: [true] sigma: [10] proc_noise: [0] GPS: L1W: code_bias: sigma: [1e-8] # this implements B(s,GPS-L1W)=0 process_noise: [0] apriori_value: [0] L2W: code_bias: sigma: [1e-8] # this implements B(s,GPS-L2W)=0 process_noise: [0] apriori_value: [0] eop: estimated: [true] sigma: [10] eop_rates: estimated: [true] sigma: [10] network_clocks_and_biases.yaml</p>
<p >//end of doc version</p>
<p >/** Ionosphere-free PPP with floating ambiguities.</p>
<p >Ionosphere-free combinations allow some atmospheric effects and biases to be eliminated from calculations, providing a simplified estimation model. As the end-user processing mode cannot calculate satellite states, the satellite position and clock offset needs to be provided externally.</p>
<p >Here the yaml configures the software to process data with an <code>epoch_interval</code> of 30s. Higher and lower intervals may be set to use more or less of the input observations.</p>
<p >Precision inputs are supplied to ensure the best possible PPP processing:</p>
<p >The PEA supports SP3 formatted satellite position inputs, specified in <code>sp3_files</code>, and RINEX clock files, <code>clk_files</code>.</p>
<p >ANTEX files, with antenna information for both stations and satellites should be provided in <code>atx_files</code></p>
<p >SINEX files, with station antennas should be provided in <code>snx_files</code></p>
<p >If no precise ephemerides (SP3/CLK) are available, RINEX 3.XX navigation files, with broadcast clocks should be provided in <code>nav_files</code></p>
<p >BLQ formatted ocean tide loading parameters for each station should be provided in <code>blq_files</code> if available to correct for OTL, otherwise <code>processing_options: tide_otl</code> should be set to <code>false</code>.</p>
<p >RINEX 3.XX observation files for the network stations are provided in <code>gnss_observations: rnx_files</code></p>
<p >The constellations to be used in processing can be specified by setting the <code>processing_options: gnss_general: sys_options: XXX: process:</code> option <code>true</code> for each system <code>XXX</code> (GPS/GLO/GAL/BDS)</p>
<p >This example demonstrates a static receiver with 0 process noise. The tracking of a moving receiver can be done by setting the <code>estimation_parameters: stations: pos: proc_noise</code> parameter to the maximum expected velocity. Smoothness of velocity can also be achieved by setting <code>estimation_parameters: stations: pos_rate: estimate</code> to <code>[true]</code>.</p>
<p >Tropospheric delays are estimated as a combination of hydrostatic and wet components, each component is in turn estimated as the products of the zenith delay and a mapping function. If <code>estimation_parameters: stations: trop: estimate</code> is set to <code>[true]</code>, the PEA estimates the zenith wet delay. If <code>estimation_parameters: stations: trop_grad: estimate</code> is set to <code>[true]</code>, the PEA also estimates azimuthal components of tropospheric mapping functions.</p>
<p >The hydrostatic zenith delays and elevation dependent component of mapping functions are calculated based on pre-defined models. Available models, which can be selected using the <code>processing_options: troposphere: model</code> parameter, are the GPT2 and VMF3 models. If using the GPT2 model the path to the necessary grid file needs to be specified in <code>inputs: troposphere: gpt2grid_files</code></p>
<p >If using the VMF3 model, the tropospheric parameters corresponding to the observation times need to be provided in a directory specified by <code>inputs: troposphere: vmf3_directory</code>, and the orography file for atmospheric circulation models need to be specified in <code>inputs: troposphere: orography_files</code></p>
<p ><code>ex11_pea_pp_user_gps.yaml</code></p>
<div class="fragment"></div><!-- fragment --><p >*/ example Ex11() { <a class="el" href="Pea_8cpp.html#a3178f0dd16294eabf532179224546750" title="Read a .yaml formatted configuration file.">Pea_Configuration()</a>; }</p>
<p >/** Ionosphere-free receiver positioning for multiple GNSS systems.</p>
<p >This example is largely the same as the previous, however the galileo system is also enabled by setting <code>processing_options: gnss_general: sys_options: gal: process: true</code></p>
<p ><code>ex12_pea_pp_user_gnss.yaml</code></p>
<div class="fragment"></div><!-- fragment --><p >*/ example Ex12() { <a class="el" href="Pea_8cpp.html#a3178f0dd16294eabf532179224546750" title="Read a .yaml formatted configuration file.">Pea_Configuration()</a>; }</p>
<p >/** Single-frequency user-mode positioning.</p>
<p >Single-frequency positioning enables low-cost receivers that do not output observations on a secondary frequency to utilise atmospheric products and estimate precise positions.</p>
<p >It is possible to perform end user PPP processing using single frequency data (although at reduced accuracy) by providing external Ionospheric delay data.</p>
<p >The PEA currently uses IONEX formatted VTEC maps as Ionosphere delay data. The path to the IONEX file needs to be specified in <code>ion_files</code></p>
<p >In order for the PEA to use the VTEC maps, the <code>processing_options: ionosphere: corr_mode</code> parameter should to be set to <code>total_electron_content</code></p>
<p >If provided separately, files containing the satellite DCB (either RINEX DCB or bias SINEX) should be specified in <code>dcb_files</code> or <code>bsx_files</code></p>
<p ><code>ex13_pea_pp_user_gps_sf.yaml</code></p>
<div class="fragment"></div><!-- fragment --><p >*/ example Ex13() { <a class="el" href="Pea_8cpp.html#a3178f0dd16294eabf532179224546750" title="Read a .yaml formatted configuration file.">Pea_Configuration()</a>; }</p>
<p >/** Dual frequency PPP with ambiguity resolution</p>
<p >The PEA (in both network and user processing modes) can be specified to perform ambiguity resolution in an attempt to improve accuracy and convergence times.</p>
<p >In aside from the requirements for floating PPP ambiguities, information on satellite hardware biases needs to be provided order to allow correct ambiguity resolution in end user PEA processing.</p>
<p >For post-process, the PEA use bias SINEX formatted files as input channels for satellite hardware biases. The bias SINEX file can be specified in <code>bsxfiles</code>.</p>
<p >The ambiguity resolution process is controlled by the <code>ambiguity_resolution_options</code> field. Currently ambiguity resolution is only supported for GPS and Galileo satellites.</p>
<p >Ambiguity resolution for a system can be activated by setting the <code>ambiguity_resolution</code> parameter to <code>true</code> within its <code>sys_options</code> fields.</p>
<p >In addition the ambiguity resolution algorithm needs to be specified for both the wide-lane ambiguity (<code>WL_mode</code>) and narrow-lane ambiguities (<code>NL_mode</code>)</p>
<p >For best results, <code>round</code> or <code>iter_rnd</code> are recommended for Wide-lane ambiguities and <code>lambda_alt</code> or <code>lambda_bie</code> is recommended for narrow-lane ambiguities.</p>
<p ><code>ex14_pea_pp_user_gnss_ar.yaml</code></p>
<div class="fragment"></div><!-- fragment --><p >*/ example Ex14() { <a class="el" href="Pea_8cpp.html#a3178f0dd16294eabf532179224546750" title="Read a .yaml formatted configuration file.">Pea_Configuration()</a>; }</p>
<p >/** Real-time PPP and RTCM</p>
<p >The PEA can be used to process GNSS data in real-time, or from RTCM files saved to disk.</p>
<p >Real-time processing will make use of RTCM formatted streams for receiver observables and satellite data.</p>
<p >Satellite positions needs to be provided using (predicted) SP3 files or using real-time streams (broadcast + SSR corrections).</p>
<p >In the <code>processing_options</code> field, the <code>ppp_ephemeris</code> parameter needs to be set to <code>precise</code> if using SP3 files and <code>ssr</code> if using SSR correction streams.</p>
<h3><a class="anchor" id="autotoc_md592"></a>
Real-time Streams</h3>
<p >This example is configured for using stored RTCM messages, but can be edited to use realtime streams by uncommenting the parameters in <code>gnss_observations</code> and <code>satellite_data</code></p>
<p >Currently the PEA can only get real-time data by connecting to an NTRIP caster.</p>
<p >An example of such a caster, can be accessed by registering at <a href="https://www.auscors.ga.gov.au/">https://www.auscors.ga.gov.au/</a></p>
<p >You can test your username and password is working correctly by running the curl command: </p><pre class="fragment">curl https://ntrip.data.gnss.ga.gov.au/ALIC00AUS0 -H "Ntrip-Version: NTRIP/2.0" -i  --output - -u &lt;user&gt;
</pre><p >The host name, user name and password corresponding to the NTRIP can be specified under <code>gnss_observations: root_stream_url</code> using the format <code>http(s)://&lt;USER&gt;:&lt;PASSWORD&gt;@hostname/</code> The username and password can use the the tags shown, and be passed in via the command line with <code>-u</code>, <code>-p</code>, or they can be hard-coded within the yaml file. Alternatively the mountpoints can be specified using the full path <code>http(s)://user:password@hostname/mountpoint</code>, leaving the <code>root_stream_url</code> field empty, this allows to use streams from multiple NTRIP casters.</p>
<p >The mountpoint corresponding to station observables can then be listed under <code>gnss_observations: streams</code></p>
<p >Ephemeris streams (broadcast ephemeris and SSR corrections) can be listed under <code>satellite_data: streams</code></p>
<p >When SSR corrections are used for ephemerides, the <code>ssr_antenna_offset</code> parameter needs to be specified to clarify whether the streams are reporting phase center positions, or center of mass positions.</p>
<p >The PEA support MSM4, MSM5, MSM6 and MSM7 messages for observations, and orbit and clock messages, code bias messages and phase bias messages for GPS and Galileo.</p>
<p >In this example the streams are being obtained from the auscors caster run by Geoscience Australia. The broadcast information is being obtained from the stream <code>BCEP00BKG0</code> being supplied by BKG, and corrections to the utlra-rapid predicted orbit are being obtained from the stream <code>SSRA00CNE0</code>. The real-time data being processed is for the continuous GNSS station located at Alice Springs obtained from the stream <code>ALIC00AUS0</code>.</p>
<h3><a class="anchor" id="autotoc_md593"></a>
Processing timing and synchronisation</h3>
<p >When processing in real-time, with latency between reception of messages from different stations, the synchonisation of observations becomes important.</p>
<p >Within the <code>epoch_control:</code> block, the <code>epoch_interval</code> is used to set the update interval as per usual, however the <code>wait_next_epoch</code> and <code>wait_all_stations</code> parameters help synchronise station streams.</p>
<p >The PEA will wait for <code>wait_next_epoch</code> seconds from the start of the previous epoch for the first observation to arrive (and skip the current epoch if no observations arrive).</p>
<p >The PEA will wait for <code>wait_all_stations</code> seconds from the first observation for data from other stations before processing.</p>
<p ><code>ex15_pea_rt_user_gnss_ar.yaml</code></p>
<div class="fragment"></div><!-- fragment --><p >*/ example Ex15() { <a class="el" href="Pea_8cpp.html#a3178f0dd16294eabf532179224546750" title="Read a .yaml formatted configuration file.">Pea_Configuration()</a>; }</p>
<p >/** Post process estimation of atmospheric delays</p>
<p >The PEA is capable of estimation both Tropospheric and Ionospheric delays on GNSS signals. Tropospheric delays can be estimated both in network (<code>processing_options: process_modes: network: true</code>) and end-user (<code>processing_options: process_modes: user: true</code>) modes.</p>
<p >Ionosphere delay estimation and mapping is activated by setting <code>processing_options: process_modes: ionosphere</code> to <code>true</code>.</p>
<p >Two types of Ionosphere delay estimates are supported by PEA. If all other parameters in the <code>processing_options: process_modes</code> field are set to <code>false</code> then the Ionospheric delay are estimated based on carrier smoothed pseudoranges. If in addition to <code>processing_options: process_modes: ionosphere</code>, <code>processing_options: process_modes: network</code> is set to true, the PEA will attempt to calculate Ionospheric delay measurements from ambiguity resolved carrier phase measurements. For this mode to work, the parameters in the <code>ambiguity_resolution_options</code> field needs to be set properly. Ionospheric delay estimate are available for GPS signals only.</p>
<p >The Ionosphere slant delay measurements delay measurements can be outputted into STEC files if <code>outputs: ionstec: output</code> parameter is set to <code>true</code></p>
<p >The format of STEC files have one of two forms. If the vector in <code>gnss_models: ionospheric_model: layer_heights</code> is not empty, each line on the STEC file will contain the slant delay measurements and the piercing points at each layer height: </p><pre class="fragment">#IONO_MEA, 2102,171000.000, AGGO, G05, -1.6030, 1.9699e-04, 2, 1, 350, -33.662, -61.955, 1.443
</pre><p> the fields representing, from left to right:</p>
<ol type="1">
<li><code>IONO_MEA</code> label</li>
<li>GPS week</li>
<li>GPS TOW in seconds</li>
<li>Receiver/station name</li>
<li>Satellite ID</li>
<li>Slant delay in meters</li>
<li>Slant delay variance in meters$^2$</li>
<li>Number of Ionosphere layers N</li>
<li>N fields containing: a. Height of layer in Km b. Latitude of piercing point (in degrees) c. Longitude of piercing point (in degrees) d. Slant to vertical mapping function</li>
</ol>
<p >If the layer heights field is empty the "Number of Ionosphere layers" field will be 0 and followed by the receiver position in ECEF, and the satellite position in ECEF.</p>
<p >Vertical TEC (VTEC) maps can be estimated from the slant delay measurements and output as IONEX formatted maps ( <code>output_files: output_ionex: true</code>) and its corresponding DCB ( <code>output_files: output_biasSINEX: true</code>).</p>
<p >Ionosphere mapping and output are controlled by parameters in the <code>ionosphere_filter_parameters</code> field. Currently only spherical harmonics based mapping is supported by the PEA <code>model = spherical_harmonic</code>, setting <code>ionosphere_filter_parameters: model</code> to <code>meas_out</code> will output the ionosphere measurements but will not perform mapping.</p>
<p >If spherical harmonics is selected as mapping method, the ionospheric delays will be mapped into multiple thin layer shells. The height of the shells can be set in the <code>ionosphere_filter_parameters: layer_heights</code> vector.</p>
<p >The VTEC at each layer will be fit to spherical harmonic components, with a maximum order and degree of <code>ionosphere_filter_parameters: func_order</code>. If <code>output_files: output_ionex</code> is set to <code>true</code> the Ionosphere map will be outputted in IONEX 1.11 format.</p>
<p >The area of the IONEX map can be set using the <code>lat_center</code>, <code>lon_center</code>, <code>lat_width</code>, <code>lon_width</code> parameters. The horizontal resolution of the IONEX map can be set using the <code>lat_res</code>, <code>lon_res</code> parameters. The temporal resolution of the IONEX file is defined by the <code>time_res</code> parameter.</p>
<p >This configuration file can be used to generate a single layer IONEX map and accompanying biasSINEX file from smoothed pseudorange observations.</p>
<p ><code>ex16_pea_pp_ionosphere.yaml</code></p>
<div class="fragment"></div><!-- fragment --><p >*/ example Ex16() { <a class="el" href="Pea_8cpp.html#a3178f0dd16294eabf532179224546750" title="Read a .yaml formatted configuration file.">Pea_Configuration()</a>; }</p>
<p >/** Satellite clock, bias, and orbit estimation, Minimum-constraints, network-Mode</p>
<h2><a class="anchor" id="autotoc_md594"></a>
Processing a Global Network to Adjust Satellite Positions</h2>
<p >PEA is currently designed to use integrated/predicted satellite positions for its real-time network processing mode, thus all satellite position corrections can only be made in post process mode.</p>
<p ><a class="el" href="structA.html">A</a> basic example for PEA network processing is provided here.</p>
<p >In order to activate estimation of satellite position corrections the entry <code>estimation_parameters: satellites: orb: estimated</code> needs to be set to <code>[true]</code>.</p>
<p >It will also require an ICF file, generated by POD in orbit fitting mode, as input. The path to such file should be given in <code>orb_files</code> entry.</p>
<p >The main output of this processing mode would be an ICF formatted file containing the corrected initial conditions for each of the processed satellites. The file will be created in the same path as the input ICF file with the <code>_pea</code> suffix attached. This file can be used by the POD to integrate/predict the satellite positions over the required time window.</p>
<p >Receiver/station positions can also be estimated as part of the network processing. In order to estimate station positions, the parameter <code>estimation_parameters: stations: pos: estimated</code> and <code>output_files: sinex: output</code> need to be set to <code>true</code> <a class="el" href="structA.html">A</a> SINEX formatted file with the estimated station position will be generated in the path specified.</p>
<h2><a class="anchor" id="autotoc_md595"></a>
Post process estimation of Satellite clocks and biases</h2>
<p >The example configuration file shown corresponds to a post-mission network processing mode for GPS satellite clocks.</p>
<p >The required input files are similar to the satellite position estimation example. The main difference will be that SP3 formatted files can be used as input for satellite position (POD generated ICF files can also be used).</p>
<p >The frequency in which the GNSS parameter are estimated, including satellite and receiver clocks, should be set by the <code>epoch_interval</code> parameter.</p>
<p >In order to estimate the satellite and receiver hardware biases, the ambiguities need to be separated from the biases and resolved to integer values.</p>
<p >In order to perform ambiguity resolution, the proper parameters needs to be set on the <code>ambiguity_resolution</code> fields.</p>
<p >The target constellations need to be selected by setting <code>GPS_amb_resol</code> and/or <code>GAL_amb_resol</code> to true (only GPS and GAL constellation are supported in the current version).</p>
<p >Both <code>WL_mode</code> and <code>NL_mode</code> needs to be set to something different than <code>off</code>.</p>
<p >It is advised that <code>round</code> or <code>iter_rnd</code> be used for network processing.</p>
<p >In order to output the estimated biases the parameter <code>output_files: output_biasSINEX</code> needs to be to <code>true</code> and <code>ambiguity_resolution_options: bias_output_rate</code> set to a number (of seconds) different than zero. The satellite biases will then be output to a bias SINEX formatted file specified in <code>output_files: biasSINEX_filename</code>.</p>
<p >Receiver biases are also estimated by the process, however they are not reflected on the output files.</p>
<h2><a class="anchor" id="autotoc_md596"></a>
Minimal constraints transformation.</h2>
<p >If minimum constraints is enabled, a rigid transformation between the estimated and apriori positions will be applied after the completion of all forward processing, and configured according to the yaml file. Here the module is enabled, and both <code>translation</code> and <code>rotation</code> are set <code>estimated: [true]</code>, and <code>scale_by_vcv</code> is used to weight station positions according to their estimated covariance.</p>
<p ><code>ex17_pea_pp_netw_gnss_ar.yaml</code></p>
<div class="fragment"></div><!-- fragment --><p >*/ example Ex17() { <a class="el" href="Pea_8cpp.html#a3178f0dd16294eabf532179224546750" title="Read a .yaml formatted configuration file.">Pea_Configuration()</a>; }</p>
<p >/** Real-time estimation of Satellite clocks and biases</p>
<p >This example is an extension of the realtime user example, converted to network PPP mode, and with configuration for outputs of streams.</p>
<p >The estimated clock and bias can be output to an NTRIP caster (as well as to local files).</p>
<p >The output NTRIP caster streams need to be specified using the <code>streams</code> field in the <code>outputs:</code> block The host name, user name and password can be set in the <code>root_stream_url</code> parameter.</p>
<p >Once the label is created, the mountpoint and RTCM messages to encode can be specified in the <code>output_streams: label</code> field.</p>
<p >Currently the PEA supports output for GPS and Galileo orbits and clock messages (1060 and 1243), code bias (1059 and 1243) and phase bias (1265 and 1267).</p>
<p >The uploading of corrections requires the use of <code>mongo</code>, which needs to be installed and configured within the yaml(s)</p>
<p >It also requires specification of the <code>ssr_corrections</code> block, which identifies the source of the corrections that will be uploaded.</p>
<p ><code>ex18_pea_rt_netw_gnss_ar.yaml</code></p>
<div class="fragment"></div><!-- fragment --><p >*/ example Ex18() { <a class="el" href="Pea_8cpp.html#a3178f0dd16294eabf532179224546750" title="Read a .yaml formatted configuration file.">Pea_Configuration()</a>; } </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
